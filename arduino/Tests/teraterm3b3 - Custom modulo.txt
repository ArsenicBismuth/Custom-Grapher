Faster, ~400-450us, or ~100us compared to initial (shifting method).
Removing the algorithm inside the alternate function shows similar result,
means it has very low performance impact.

Below specified only on filter function

-60.17  112     616     40      44      272     80      1164
-60.17  112     4       48      44      284     80      572
-60.18  116     660     40      44      280     80      1220
-60.18  112     4       56      44      276     80      572
-60.19  116     616     40      68      272     80      1192
-60.19  112     4       48      44      276     76      560
-60.20  116     656     40      48      280     76      1216
-60.20  116     4       48      52      276     80      576
-60.21  112     620     40      44      276     80      1172
-60.21  112     4       48      44      280     80      568
-60.22  116     656     40      68      296     80      1256
-60.22  112     4       48      52      284     80      580
-60.22  116     616     44      40      284     80      1180
-60.23  112     4       48      44      280     80      568
-60.24  116     656     44      40      288     76      1220
-60.24  112     4       48      44      276     80      564
-60.25  116     616     44      64      276     80      1196
-60.25  112     4       48      44      280     80      568
-60.26  116     656     44      40      276     80      1212
-60.26  116     4       48      44      288     80      580
-60.27  116     620     40      44      272     80      1172
-60.27  112     4       48      44      280     80      568
-60.28  116     656     44      64      284     80      1244
-60.28  108     4       48      44      280     80      564
-60.29  116     620     40      44      272     76      1168
-60.29  116     4       48      44      272     80      564
-60.29  116     660     40      44      276     80      1216
-60.30  116     4       48      44      276     84      572
-60.31  116     620     44      64      300     80      1224
-60.31  116     4       48      44      284     84      580
-60.31  116     664     40      44      288     80      1232
-60.32  116     4       48      44      288     84      584
-60.33  112     624     40      44      284     76      1180
-60.33  112     4       48      44      276     76      560


Below is full implementation on entire program
See the visible increase in on the 4th rightmost data, which is
the modulo between n and (DS0 * DS1 * DS2 / US3). As expected,
the bigger the distance between divisor & dividend, the slower it's.
Notice that it's the upsampling.

While with the 5th from rightmost, it's increasing pretty significant
actually, with value around 60us at 10,000th data.

So, it's indeed faster, but it gets slower over time

-0.02   116     24      4       8       256     76      484
-0.03   116     584     4       4       260     72      1040
-0.03   116     24      4       4       252     76      476
-0.03   116     592     4       28      252     76      1068
-0.04   116     16      4       16      256     76      484
-0.05   112     596     4       4       248     76      1040
-0.05   116     16      4       16      268     72      492
-0.05   116     600     4       4       256     76      1056
-0.06   112     16      4       16      264     76      488
-0.07   116     600     4       28      256     76      1080
-0.07   116     16      4       16      248     76      476
-0.08   116     596     4       8       248     76      1048
-0.08   112     16      4       16      248     76      472
-0.09   112     600     4       8       248     76      1048
// 30 data later
-0.24   116     16      12      16      260     76      496
// 300 data later
-1.75   112     680     4       124     276     76      1272
-1.75   116     16      16      72      268     76      564
-1.75   116     680     8       72      260     76      1212
-1.76   112     16      8       88      272     76      572
-1.76   112     684     4       72      268     76      1216
-1.77   116     16      16      72      272     76      568
-1.77   112     676     4       124     276     76      1268
// 1470 data later
-9.13   116     16      20      372     276     76      876
-9.14   116     676     12      364     284     80      1532
-9.14   112     16      20      372     288     80      888
-9.15   120     672     12      372     280     80      1536
-9.15   116     16      20      372     280     80      884
-9.15   116     672     12      420     276     80      1576
-9.16   116     16      20      368     272     76      868
-9.17   112     676     8       376     264     76      1512
-9.17   116     28      8       368     272     80      872
-9.18   112     676     8       376     272     80      1524

Below at ~13,000 data
-66.47  108     20      60      2652    284     80      3204
-66.47  116     684     52      2652    284     80      3868
-66.48  116     16      64      2652    276     80      3204
-66.48  112     684     52      2676    276     80      3880
-66.49  116     16      64      2652    276     76      3200
-66.50  116     688     52      2652    280     76      3864

Either avoid optimizing it, or just find a method to increment the global index

Optimizing global index, separating the one used for modulation and downsampling.
Very good, faster ~40us

-0.57   116     660     4       16      280     76      1152
-0.58   112     16      4       52      280     84      548
-0.59   116     668     4       20      276     76      1160
-0.60   116     16      4       28      280     80      524
-0.01   112     672     1136    40      268     80      2308
-0.02   112     16      4       28      268     80      508
-0.03   116     636     4       20      260     84      1120
-0.04   112     16      4       52      264     80      528
-0.05   112     640     4       16      276     76      1124
-0.06   112     16      4       28      256     88      504
